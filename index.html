<!DOCTYPE html>
<meta charset="utf-8" />
<html>
  <head>
    <!-- <script src="https://d3js.org/d3.v5.min.js"></script> -->
    <script src="js/d3.min.js"></script>
    <script src="js/d3-array.min.js"></script>

    <style>
      body {
        font: 12px sans-serif;
        margin: 4px 20px 0px 20px;
        /* background: gray; */
        background-color: whitesmoke;
      }

      .top {
        background-color: whitesmoke;
        overflow: hidden;
        position: fixed;
        top: 0;
        width: 100%;
      }

      .main {
        margin-top: 400px;
      }
    </style>
  </head>
  <body>
    <h2>COVID-19 Index Chart Visualization</h2>
    <h3>Description:</h3>

    <h3>Controls:</h3>
    <label for="countrySelect">Country: </label>
    <select id="countrySelect" onChange="countrySelectChanged()">
    </select>
    <br/><br/>

    <label for="countryDetailSelect">Country Detail: </label>
    <select id="countryDetailSelect" onChange="countryDetailSelectChanged()" disabled>
      <option selected>Country</option>
    </select>
    <br/><br/>

    <label for="stateSelect">State/Province: </label>
    <select id="stateSelect" onChange="stateSelectChanged()" disabled>
    </select>
    <br/><br/>

    <label for="countySelect">US County: </label>
    <select id="countySelect" onChange="countySelectChanged()" disabled>
    </select>
    <br/><br/>

    <hr>

    <h3>Charts:</h3>
    <div id="charts"></div>

  </body>

  <script>
    let parseTime = d3.timeParse("%m/%d/%Y");
    let allFileData;
    let chartData;
    let svg;
    const chartHeight = 200;
    const margin = {top: 20, right: 40, bottom: 20, left: 60};

    const removeSpaces = (str) => {
      return str.replace(/\s+/g, '');
    };

    const getSelectedCountry = () => {
      const select = document.getElementById('countrySelect');
      return select.options[select.selectedIndex].text;
    }

    const getSelectedCountryDetail = () => {
      const select = document.getElementById('countryDetailSelect');
      return select.options[select.selectedIndex].text;
    }

    const countrySelectChanged = () => {
      populateStateSelect();
      populateCountySelect();
      populateCountryDetailSelect();
      createCharts();
    }

    const populateCountriesSelect = (countries) => {
      const select = document.getElementById('countrySelect');
      countries.unshift('All Countries');
      countries.forEach(country => {
        select.options[select.options.length] = new Option(country);
      });
    };

    const populateCountryDetailSelect = () => {
      const select = document.getElementById('countryDetailSelect');
      for (let i = select.options.length - 1; i >= 0; i--) {
        select.remove(i);
      }

      const selectedCountry = getSelectedCountry();
      if (selectedCountry === 'All Countries') {
        select.disabled = true;
      } else {
        var detailOptions = [];
        var selectedCountryData = allFileData[0].countries.find(d => d.name === selectedCountry);
        if (selectedCountryData.values.length > 0) {detailOptions.push('Country')};
        if (selectedCountryData.states.length > 0) {detailOptions.push('State/Province')};
        if (selectedCountryData.counties.length > 0) {detailOptions.push('County')};
        select.disabled = false;
        detailOptions.forEach(option => {
          select.options[select.options.length] = new Option(option);
        });
      }
    }

    const populateStateSelect = () => {
      const select = document.getElementById('stateSelect');
      for (let i = select.options.length - 1; i >= 0; i--) {
        select.remove(i);
      }

      const selectedCountry = getSelectedCountry();
      if (selectedCountry === 'All Countries') {
        select.disabled = true;
      } else {
        var selectedCountryData = allFileData[0].countries.find(d => d.name === selectedCountry);
        if (selectedCountryData && selectedCountryData.states.length > 0) {
          const stateNames = selectedCountryData.states.map(d => d.name);
          stateNames.unshift('All States/Provinces');
          stateNames.forEach(stateName => {
            select.options[select.options.length] = new Option(stateName);
          })
          select.disabled = false;
        } else {
          select.disabled = true;
        }
      }
    }

    const populateCountySelect = () => {
      const select = document.getElementById('countySelect');
      for (let i = select.options.length - 1; i >= 0; i--) {
        select.remove(i);
      }

      const selectedCountry = getSelectedCountry();
      if (selectedCountry === 'All Countries') {
        select.disabled = true;
      } else {
        var selectedCountryData = allFileData[0].countries.find(d => d.name === selectedCountry);
        if (selectedCountryData && selectedCountryData.counties.length > 0) {
          const countyNames = selectedCountryData.counties.map(d => d.name);
          console.log(countyNames);
          countyNames.unshift('All Counties');
          countyNames.forEach(countyName => {
            select.options[select.options.length] = new Option(countyName);
          })
          select.disabled = false;
        } else {
          select.disabled = true;
        }
      }
    }

    const countryDetailSelectChanged = () => {
      const selectedDetail = getSelectedCountryDetail();
      if (selectedDetail === 'Country') {
        document.getElementById('stateSelect').disabled = true;
        document.getElementById('countySelect').disabled = true;
      } else if (selectedDetail === 'State/Province') {
        document.getElementById('stateSelect').disabled = false;
        document.getElementById('countySelect').disabled = true;
      } else if (selectedDetail === 'County') {
        document.getElementById('stateSelect').disabled = true;
        document.getElementById('countySelect').disabled = false;
      }
      createCharts();
    }

    const processData = (rawFileData) => {
      if (rawFileData) {
        var processedData = [];
        rawFileData.forEach(fileData => {
          const nestedData = d3.nest()
            .key(d => d["Country/Region"]).sortKeys(d3.ascending)
            .key(d => d["Province/State"]).sortKeys(d3.ascending)
            .entries(fileData.data);
          
          var dates = [];
          fileData.data.columns.forEach(column => {
            const date = parseTime(column);
            if (date) {
              dates.push(column);
            }
          });

          var countries = [];
          nestedData.forEach(countryNode => {
            var country = {
              name: countryNode.key,
              values: null,
              states: [],
              counties: []
            };
            countries.push(country);

            countryNode.values.forEach(stateNode => {
              var values = dates.map(date => stateNode.values[0][date]);
              if (stateNode.key !== "null" && stateNode.key !== countryNode.key) {
                if (stateNode.key.includes(",")) {
                  country.counties.push({
                    name: stateNode.key,
                    values: values
                  });
                } else {
                  country.states.push({
                    name: stateNode.key,
                    values: values
                  });
                }
              } else {
                country.values = values;
              }
            });

            if (!country.values) {
              // need to sum up states to get country totals
              // console.log(country.name + " needs rollup");
              country.values = Array.from(country.states[0].values);
              for (let i = 1; i < country.states.length; i++) {
                for (let j = 0; j < country.values.length; j++) {
                  country.values[j] = country.values[j] + country.states[i].values[j];
                }
              }
            }
          });

          var name = fileData.filename.includes("Confirmed") ? "Confirmed" : fileData.filename.includes("Deaths") ? "Death" : fileData.filename.includes("Recovered") ? "Recovered" : "Other";          
          processedData.push({
            name: name,
            title: `${name} Case Counts`,
            y: "Cases",
            countries: countries,
            dates: dates.map(d => parseTime(d))
          });

        });
        return processedData;
      }
    };

    const loadData = () => {
      if (allFileData) {
        const selectedCountry = getSelectedCountry();
        console.log(selectedCountry);

        chartData = [];

        if (selectedCountry === 'All Countries') {
          allFileData.forEach(fileData => {
            var series = [];
            // console.log(fileData);
            fileData.countries.forEach(countryData => {
              // if (countryData.values) {
                series.push({
                  name: countryData.name,
                  values: countryData.values
                });
              // }
            });
            chartData.push({
              name: fileData.name,
              title: fileData.title,
              y: fileData.y,
              series: series,
              dates: fileData.dates
            });
          });
        } else {
          allFileData.forEach(fileData => {
            var series = [];
            const country = fileData.countries.find(d => d.name === selectedCountry);
            const selectedCountryDetail = getSelectedCountryDetail();
            if (selectedCountryDetail === 'State/Province') {
              if (country.states.length > 0) {
                country.states.forEach(state => {
                  series.push({
                    name: state.name,
                    values: state.values
                  });
                });
              } else {
                series.push({
                  name: country.name,
                  values: country.values
                });
              }
            } else if (selectedCountryDetail === 'County') {
              if (country.counties.length > 0) {
                country.counties.forEach(county => {
                  series.push({
                    name: county.name,
                    values: county.values
                  });
                });
              } else {
                series.push({
                  name: country.name,
                  values: country.values
                });
              }
            }
            
            chartData.push({
              name: fileData.name,
              title: fileData.title,
              y: fileData.y,
              series: series,
              dates: fileData.dates
            });
          });
        }
      }

      console.log(chartData);
    }

    const oldloadData = () => {
      if (allFileData) {
        const selectedCountry = getSelectedCountry();
        console.log(selectedCountry);

        chartData = [];
        allFileData.forEach(fileData => {
          const nestedCountries = d3.nest()
            .key(d => d["Country/Region"])
            .entries(fileData.data);
          console.log(nestedCountries);

          filteredData = fileData.data.filter(d => d["Country/Region"] === 'US').filter(d => !d["Province/State"].includes(','))
          const nestedGroups = d3.nest()
            .key(d => d["Country/Region"])
            .key(d => d["Province/State"])
            .entries(filteredData);

          // console.log(nestedGroups);

          // extract dates
          var dates = [];
          fileData.data.columns.forEach(column => {
            const date = parseTime(column);
            if (date) {
              dates.push(column);
            }
          });

          // extract series data
          var series = [];
          nestedGroups.forEach(countryNode => {
            countryNode.values.forEach(stateNode => {
              var values = [];
              values = dates.map(date => {
                return stateNode.values[0][date];
                // return {
                //   date: parseTime(date),
                //   value: stateNode.values[0][date]
                // }
              });

              series.push({
                // country: countryNode.key,
                // state: stateNode.key,
                name: `${countryNode.key}:${stateNode.key}`,
                values: values
              });
            });
          });

          var name = fileData.filename.includes("Confirmed") ? "Confirmed" : fileData.filename.includes("Deaths") ? "Death" : fileData.filename.includes("Recovered") ? "Recovered" : "Other";
          chartData.push({
            name: name,
            title: `${name} Case Counts`,
            y: "Cases",
            series: series,
            dates: dates.map(d => parseTime(d))
          });

          console.log(chartData);
        });
      }
    };

    const createChart = (divID, data) => {
      // console.log(data);
      const divWidth = document.getElementById(divID).clientWidth;
      const width = divWidth;
      const height = chartHeight;

      const svg = d3.select(`#${divID}`).append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);
        
      const x = d3.scaleUtc()
        .domain(d3.extent(data.dates))
        .range([margin.left, width - margin.right]);
        // .nice();

      const y = d3.scaleLinear()
        .domain([0, d3.max(data.series, s => d3.max(s.values))])
        .range([height - margin.bottom, margin.top]);
      
      const xAxis = g => g
        .attr("transform", `translate(0, ${height - margin.bottom})`)
        .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0))
      
      const yAxis = g => g
        .attr("transform", `translate(${margin.left},0)`)
        .call(d3.axisLeft(y))
        .call(g => g.select(".domain").remove())
        .call(g => g.select(".tick:last-of-type text").clone()
          .attr("x", 3)
          .attr("text-anchor", "start")
          .attr("font-weight", "bold")
          .text(data.y));
      
      const line = d3.line()
        .defined(d => !isNaN(d))
        .x((d, i) => x(data.dates[i]))
        .y(d => y(d));
        // .y(d => d === 0 ? y.range()[0] : y(d));

      svg.append("g").append("text")
        .attr("x", margin.left)
        .attr("y", margin.top - 10)
        .attr("fill", "black")
        .style("font-weight", "bold")
        .style("font-size", 12)
        .style("text-anchor", "start")
        .text(data.title);

      svg.append("g").call(xAxis);
      svg.append("g").call(yAxis);

      const path = svg.append("g")
          .attr("fill", "none")
          .attr("stroke", "dodgerblue")
          .attr("stroke-width", 1.5)
          .attr("stroke-linejoin", "round")
          .attr("stroke-linecap", "round")
        .selectAll("path")
        .data(data.series)
        .join("path")
          .style("mix-blend-mode", "multiply")
          .attr("d", d => line(d.values));

      function hover(svg, path) {
        if ("ontouchstart" in document) svg
            .style("-webkit-tap-highlight-color", "transparent")
            .on("touchmove", moved)
            .on("touchstart", entered)
            .on("touchend", left)
        else svg
            .on("mousemove", moved)
            .on("mouseenter", entered)
            .on("mouseleave", left);

        const dot = svg.append("g")
            .attr("display", "none");

        dot.append("circle")
          .attr("r", 2.5);

        dot.append("text")
          .attr("font-family", "sans-serif")
          .attr("font-size", 10)
          .attr("text-anchor", "middle")
          .attr("y", -8);

        function moved() {
          d3.event.preventDefault();
          // console.log(d3.mouse);
          const ym = y.invert(d3.mouse(this)[1]);
          const xm = x.invert(d3.mouse(this)[0]);
          // console.log(`ym: ${ym}  xm: ${xm}`);
          const i1 = d3.bisectLeft(data.dates, xm, 1);
          const i0 = i1 - 1;
          const i = xm - data.dates[i0] > data.dates[i1] - xm ? i1 : i0;
          const s = d3.least(data.series, d => Math.abs(d.values[i] - ym));
          // console.log(`date: ${data.dates[i]}  value: ${s.values[i]}`);
          path.attr("stroke", d => d === s ? null : "#ddd").filter(d => d === s).raise();
          dot.attr("transform", `translate(${x(data.dates[i])},${y(s.values[i])})`);
          dot.select("text").text(`${s.name}: ${s.values[i]}`);
        }

        function entered() {
          path.style("mix-blend-mode", null).attr("stroke", "#ddd");
          dot.attr("display", null);
        }

        function left() {
          path.style("mix-blend-mode", "multiply").attr("stroke", null);
          dot.attr("display", "none");
        }
      }

      svg.call(hover, path);
    };

    const createCharts = () => {
      d3.select('#charts').selectAll('*').remove();
      if (allFileData) {
        loadData();
        if (chartData) {
          chartData.forEach(d => {
            const chartDiv = document.createElement("div");
            chartDiv.id = d.name;
            document.getElementById('charts').append(chartDiv);
            createChart(d.name, d);
          })
        }
      }
    };

    

    const loadFiles = (filenames) => {
      if (filenames) {
        let rawFileData = [];
        Promise.all(filenames.map(f => d3.csv(f, d3.autoType)))
          .then(function (d) {
            for (let i = 0; i < d.length; i++) {
              rawFileData.push({
                filename: filenames[i],
                data: d[i]
              });
            }

            let countries = new Set();
            rawFileData.forEach(fileData => {
              fileData.data.forEach(d => {
                countries.add(d["Country/Region"]);
              });
            });
            populateCountriesSelect([...countries].sort(d3.sortAscending));

            allFileData = processData(rawFileData);
            console.log(allFileData);
            createCharts();
          })
          .catch (error => {
            console.log(error);
          });
      }
    };

    const files = ['data/time_series_19-covid-Confirmed.csv', 
      'data/time_series_19-covid-Deaths.csv',
      'data/time_series_19-covid-Recovered.csv'];
    const remoteFiles = ['https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Confirmed.csv',
      'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Deaths.csv',
      'https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Recovered.csv']
    loadFiles(remoteFiles);

    // d3.csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Confirmed.csv', d3.autoType)
    // d3.csv("data/time_series_19-covid-Confirmed.csv", d3.autoType)
    //   .then(function(data) {
    //     fileData = data;
    //     loadData();
    //     createChart(chartData[0]);
    //   })
    //   .catch(function(error) {
    //     console.log(error);
    //   });
  </script>
</html>
